*This lab involves a front-end and back-end server, and the back-end server doesn't support chunked encoding. The front-end server rejects requests that aren't using the GET or POST method.
To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST.*

Right clicked the homepage request > *Extensions > HTTP Request Smuggler > Smuggle Probe*
	![Screenshot 2024-06-11 at 6.48.28 PM](images/Screenshot%202024-06-11%20at%206.48.28%20PM.png)
Decided to test this out by sending the request to the Repeater. 
Did the following as seen in [](Notes%20v1.1#HTTP%20Request%20Smuggling%20Methodology) (Steps 1-7) and sent the request for a sanity check:
	![Screenshot 2024-06-12 at 1.54.58 PM](images/Screenshot%202024-06-12%20at%201.54.58%20PM.png)
I then decided to test for the vulnerability of TE:CL since it was highlighted from the initial probe.

The frontend processes the request by respecting the `Transfer-Encoding` in the innocent request, which means the the whole request along with the smuggled request will pass through the frontend as long as the null byte with a carriage return below it is after the smuggled request and not the innocent request. 

The backend processes the request by respecting the `Content-Length` in the innocent request, which means that it will cut off the request where the characters are past the specified limit. It will return the first request only, so we have to modify the smuggled request such that it will think that the smuggled request is incomplete, and that it is waiting for the request to complete (by us the submitting the request twice). 

I hence modified the request to as such:
![Screenshot 2024-06-12 at 2.00.13 PM](images/Screenshot%202024-06-12%20at%202.00.13%20PM.png)
The goal here is to create a server timeout, where we provide a `0` chunk size that will make the backend terminate the request and process `X` as the method of an incomplete request. This `X` will be stored in the buffer, where the server will await for a subsequent request to append to the `X`. For now, we sent the attack request once, creating a timeout error after awhile and confirming the vulnerability:
![Screenshot 2024-06-12 at 2.07.45 PM](images/Screenshot%202024-06-12%20at%202.07.45%20PM.png)
We can also confirm that we can manipulate the method when sending the following request twice:
![Screenshot 2024-06-12 at 2.12.52 PM](images/Screenshot%202024-06-12%20at%202.12.52%20PM.png)
Since `0` denotes the end of the first chunk and it is in itself a 0 byte chunk size, the frontend will send both the `1` byte chunk and the `0` byte chunk to the backend. The backend will see that the `Content-Length` is 3 and will treat `G` and `0` as part of a new incomplete request. For the time being it is stored in the buffer, awaiting for the request to be complete when we send the request again.

Now let's manipulate the request to get `GPOST` method:
1. we first have to calculate the `Content-Length` of the whole request so that the full request passes through the frontend:![Screenshot 2024-06-12 at 2.48.04 PM](images/Screenshot%202024-06-12%20at%202.48.04%20PM.png)
2. we then have to find the chunk size of the smuggled request/body of the innocent request:![Screenshot 2024-06-12 at 2.50.00 PM 1](images/Screenshot%202024-06-12%20at%202.50.00%20PM%201.png)
4. we then have to find the `Content-Length` of the body smuggled request:![Screenshot 2024-06-12 at 2.48.04 PM 1](images/Screenshot%202024-06-12%20at%202.48.04%20PM%201.png)
If we send the request twice, we will receive the `Unrecognized method GPOST`, error, solving the lab:
	![Screenshot 2024-06-12 at 2.57.38 PM](images/Screenshot%202024-06-12%20at%202.57.38%20PM.png)
